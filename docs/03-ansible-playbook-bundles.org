* Create Ansible Playbook Bundles

We will create our own ServiceClasses in Ansible Service Broker and launch ServiceInstances from them.

** Prepare environment

- Follow setup steps from Setup [[./01-setup-machine.org][Setting up Environment]] section.
- Login to Openshift cluster:
  - =oc login -u admin -p admin=
- Create new namespace using =oc= tool
  - =oc new-project hello-apb=

** Create ServiceClass for app hello-world
*** Initialize empty =apb= directory

#+BEGIN_SRC bash
apb init hello-app-apb
#+END_SRC

- Go to new directory =hello-app-apb= and examine files:
  - =Dockerfile=
    - Dockerfile for image that will be used to create ServiceInstances
  - =apb.yml=
    - main definition for APB application, plans, parameters, etc.

**** Update =com.redhat.apb.spec= spec
Run =apb prepare= in =hello-app-apb= directory.

The =prepare= command will attach =base64= version of =app.yml= to link image to app definition.

*** Test build and deployment of empty apb
Again in =hello-app-apb= directory run:

#+BEGIN_SRC bash
# Build docker image
eval $(minishift docker-env) # We need to connect to Docker daemon running in minishift

apb build

# Push docker image to minishift
apb push

# List that apb is uploaded to Ansible Service Broker
apb list
#+END_SRC

*** Update APB to run =hello-world= app
- Examine files:
  - =playbooks/provision.yml=
  - =roles/provision-hello-app-apb/tasks/main.yml=

**** Update provisioning role
Open file =roles/provision-hello-app-apb/tasks/main.yml= and add following ansible tasks:

DeploymentConfig for =hello-app-apb= app:

#+BEGIN_SRC yaml
- name: create deployment config
  openshift_v1_deployment_config:
    name: hello-app-apb
    namespace: '{{ namespace }}'
    labels:
      app: hello-app-apb
      service: hello-app-apb
    replicas: 1
    selector:
      app: hello-app-apb
      service: hello-app-apb
    spec_template_metadata_labels:
      app: hello-app-apb
      service: hello-app-apb
    containers:
    - env:
      image: docker.io/ansibleplaybookbundle/hello-world:latest
      name: hello-app-apb
      ports:
      - container_port: 8080
        protocol: TCP
#+END_SRC

Service for =hello-app-apb= app:

#+BEGIN_SRC yaml
- name: create hello-app-apb service
  k8s_v1_service:
    name: hello-app-apb
    namespace: '{{ namespace }}'
    labels:
      app: hello-app-apb
      service: hello-app-apb
    selector:
      app: hello-app-apb
      service: hello-app-apb
    ports:
      - name: web
        port: 80
        target_port: 8080
#+END_SRC

Route for =hello-app-apb= app:

#+BEGIN_SRC yaml
- name: create hello-app-apb route
  openshift_v1_route:
    name: hello-app-apb
    namespace: '{{ namespace }}'
    labels:
      app: hello-app-apb
      service: hello-app-apb
    to_name: hello-app-apb
    spec_port_target_port: web
#+END_SRC

**** Update deprovisioning role
Deprovision Route for =hello-app-apb= app:
#+BEGIN_SRC yaml
- openshift_v1_route:
   name: hello-app-apb
   namespace: '{{ namespace }}'
   state: absent

#+END_SRC

Deprovision Service for =hello-app-apb= app:
#+BEGIN_SRC yaml
- k8s_v1_service:
   name: hello-app-apb
   namespace: '{{ namespace }}'
   state: absent
#+END_SRC

Deprovision DeploymentConfig for =hello-app-apb= app:
#+BEGIN_SRC yaml
- openshift_v1_deployment_config:
   name: hello-app-apb
   namespace: '{{ namespace }}'
   state: absent
#+END_SRC

**** Build and push ServiceClass to Ansible Service Broker
#+BEGIN_SRC bash
apb build
apb push
#+END_SRC
*** Deploy ServiceInstance

See [[https://github.com/openshift/ansible-service-broker/blob/master/docs/apb_integration.md#ansible-playbook-bundles-apb-integration][simple APB provisioning diagram]]

#+BEGIN_SRC bash
svcat provision hello-app --class localregistry-hello-app-apb
#+END_SRC

View Service instance status:
#+BEGIN_SRC bash
watch svcat get instance
#+END_SRC

View Resources created by Service instance:
#+BEGIN_SRC bash
oc get all
#+END_SRC

Get Route created by service instance and connect to it
#+BEGIN_SRC bash
oc get route
#+END_SRC

** Create ServiceClass for postgresql (bindable)

*** Initialize empty apb directory (including binding files)
#+BEGIN_SRC bash
apb init my-pg-apb --bindable
#+END_SRC

Go to =my-pg-apb= dir and update =app.yml= with:

#+BEGIN_SRC yaml
version: 1.0
name: my-pg-apb
description: This is a sample application generated by apb init
bindable: True
async: optional
metadata:
  displayName: my-pg
plans:
  - name: default
    description: This default plan deploys my-pg-apb
    free: True
    metadata: {}
    # edit the parameters and add the ones below.
    parameters:
      - name: postgresql_database
        title: PostgreSQL Database Name
        type: string
        default: admin
      - name: postgresql_user
        title: PostgreSQL User
        type: string
        default: admin
      - name: postgresql_password
        title: PostgreSQL Password
        type: string
        default: admin
#+END_SRC

*** Update Provision and Deprovision roles

=my-pg-apb/roles/provision-my-pg-apb/tasks/main.yml=:
#+BEGIN_SRC yaml
# New persistent volume claim
- name: create volumes
  k8s_v1_persistent_volume_claim:
    name: my-pg
    namespace: '{{ namespace }}'
    state: present
    access_modes:
      - ReadWriteOnce
    resources_requests:
      storage: 1Gi

- name: create deployment config
  openshift_v1_deployment_config:
    name: my-pg
    namespace: '{{ namespace }}'
    labels:
      app: my-pg
      service: my-pg
    replicas: 1
    selector:
      app: my-pg
      service: my-pg
    spec_template_metadata_labels:
      app: my-pg
      service: my-pg
    containers:
    - env:
      - name: POSTGRESQL_PASSWORD
        value: '{{ postgresql_password }}'
      - name: POSTGRESQL_USER
        value: '{{ postgresql_user }}'
      - name: POSTGRESQL_DATABASE
        value: '{{ postgresql_database }}'
      image: docker.io/centos/postgresql-94-centos7
      name: my-pg
      ports:
      - container_port: 5432
        protocol: TCP
      termination_message_path: /dev/termination-log
      volume_mounts:
      - mount_path: /var/lib/pgsql/data
        name: my-pg
      working_dir: /
    volumes:
    - name: my-pg
      persistent_volume_claim:
        claim_name: my-pg
      test: false
      triggers:
      - type: ConfigChange

- name: create service
  k8s_v1_service:
    name: my-pg
    namespace: '{{ namespace }}'
    state: present
    labels:
      app: my-pg
      service: my-pg
    selector:
      app: my-pg
      service: my-pg
    ports:
    - name: port-5432
      port: 5432
      protocol: TCP
      target_port: 5432

# New encoding task makes credentials available to future bind operations
- name: encode bind credentials
  asb_encode_binding:
    fields:
      DB_TYPE: postgres
      DB_HOST: my-pg
      DB_PORT: "5432"
      DB_USER: "{{ postgresql_user }}"
      DB_PASSWORD: "{{ postgresql_password }}"
      DB_NAME: "{{ postgresql_database }}"
#+END_SRC

*Note*:
The encode bind credentials task will make available several fields as environment variables, ~DB_TYPE~, ~DB_HOST~, ~DB_PORT~, ~DB_USER~, ~DB_PASSWORD~, ~DB_NAME~.
This is the default behavior when the ~bind.yml~ file is left empty.
Any application (such as hello-app) can use these environment variables to connect to the configured database after performing a bind operation.

=my-pg-apb/roles/deprovision-my-pg-apb/tasks/main.yml=:
#+BEGIN_SRC yaml
- k8s_v1_service:
    name: my-pg
    namespace: '{{ namespace }}'
    state: absent

- openshift_v1_deployment_config:
    name: my-pg
    namespace: '{{ namespace }}'
    state: absent

- k8s_v1_persistent_volume_claim:
    name: my-pg
    namespace: '{{ namespace }}'
    state: absent
#+END_SRC

**** Create ServiceClass in Ansible Service Broker

#+BEGIN_SRC bash
eval $(minishift docker-env) # We need to connect to Docker daemon running in minishift

apb build

# Push docker image to minishift
apb push

# List that apb is uploaded to Ansible Service Broker
apb list
#+END_SRC

**** Create SerivceInstance

#+BEGIN_SRC bash
svcat provision hello-pg --class localregistry-my-pg-apb -p postgresql_password=admin -p postgresql_database=admin -p postgresql_user=admin
#+END_SRC

** Bind services

#+BEGIN_SRC bash
# Create ServiceInstance binding
svcat bind hello-pg

cat > podpreset-my-db.yml <<EOF
---
kind: PodPreset
apiVersion: settings.k8s.io/v1alpha1
metadata:
  name: allow-my-pg
spec:
  selector:
    matchLabels:
      app: hello-world
  envFrom:
    - secretRef:
        name: hello-pg
EOF

oc apply -f ./podpreset-my-db.yml
#+END_SRC
